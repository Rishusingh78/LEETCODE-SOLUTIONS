class DSU {
public:
    vector<int> parent, rank;

    DSU(int n) {
        parent.resize(n+1);
        rank.assign(n+1, 0);
        for(int i=0;i<=n;i++) parent[i]=i;
    }

    int find(int x){
        if(parent[x]==x) return x;
        return parent[x]=find(parent[x]);
    }

    void unite(int a,int b){
        a=find(a); 
        b=find(b);
        if(a==b) return;

        if(rank[a]<rank[b]) swap(a,b);
        parent[b]=a;
        if(rank[a]==rank[b]) rank[a]++;
    }
};

class Solution {
public:
    
    vector<int> processQueries(int c,
                               vector<vector<int>>& connections,
                               vector<vector<int>>& queries) {

        DSU dsu(c);

        
        for(auto &e: connections)
            dsu.unite(e[0], e[1]);

        unordered_map<int, set<int>> comp;

        
        for(int i=1;i<=c;i++)
            comp[dsu.find(i)].insert(i);

        vector<bool> online(c+1, true);
        vector<int> ans;

        for(auto &q: queries) {
            int type = q[0];
            int x = q[1];

            int root = dsu.find(x);

            if(type == 1) {
                if(online[x]) {
                    ans.push_back(x);
                } else {
                    if(comp[root].empty()) ans.push_back(-1);
                    else ans.push_back(*comp[root].begin());
                }
            }
            else { 
                if(online[x]) {
                    online[x] = false;
                    comp[root].erase(x);
                }
            }
        }

        return ans;
    }
};
