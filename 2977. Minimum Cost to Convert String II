#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    long long minimumCost(string source, string target,
                          vector<string>& original,
                          vector<string>& changed,
                          vector<int>& cost) {

        int n = source.size();
        const long long INF = 1e18;

        // group rules by length
        unordered_map<int, vector<int>> byLen;
        for (int i = 0; i < original.size(); ++i)
            byLen[original[i].size()].push_back(i);

        // adjacency list per length
        unordered_map<int,
            unordered_map<string, vector<pair<string,int>>>> adj;

        for (int i = 0; i < original.size(); ++i) {
            int L = original[i].size();
            adj[L][original[i]].push_back({changed[i], cost[i]});
        }

        // memo: length -> startString -> distMap
        unordered_map<int,
            unordered_map<string, unordered_map<string,long long>>> memo;

        vector<long long> dp(n+1, INF);
        dp[0] = 0;

        for (int i = 0; i < n; ++i) {
            if (dp[i] == INF) continue;

            // same char
            if (source[i] == target[i])
                dp[i+1] = min(dp[i+1], dp[i]);

            for (auto &p : adj) {
                int L = p.first;
                if (i + L > n) continue;

                string s = source.substr(i, L);
                string t = target.substr(i, L);

                // run Dijkstra once per (L,s)
                if (!memo[L].count(s)) {
                    unordered_map<string,long long> dist;

                    priority_queue<pair<long long,string>,
                        vector<pair<long long,string>>,
                        greater<>> pq;

                    dist[s] = 0;
                    pq.push({0, s});

                    while (!pq.empty()) {
                        auto [cd, u] = pq.top();
                        pq.pop();

                        if (cd > dist[u]) continue;

                        for (auto &edge : adj[L][u]) {
                            auto &v = edge.first;
                            int w = edge.second;

                            long long nd = cd + w;

                            if (!dist.count(v) || nd < dist[v]) {
                                dist[v] = nd;
                                pq.push({nd, v});
                            }
                        }
                    }

                    memo[L][s] = move(dist);
                }

                auto &dist = memo[L][s];

                if (dist.count(t))
                    dp[i+L] = min(dp[i+L], dp[i] + dist[t]);
            }
        }

        return dp[n] == INF ? -1 : dp[n];
    }
};
