class Solution {
public:
    struct Event {
        double y;
        int type;          
        long long x1, x2;
    };

    struct SegTree {
        vector<int> cover;
        vector<long long> len;
        vector<long long> xs;

        SegTree(int n, vector<long long>& x) : xs(x) {
            cover.assign(4*n, 0);
            len.assign(4*n, 0);
        }

        void pull(int node, int l, int r) {
            if (cover[node] > 0)
                len[node] = xs[r] - xs[l];
            else if (l + 1 == r)
                len[node] = 0;
            else
                len[node] = len[node*2] + len[node*2+1];
        }

        void update(int node, int l, int r, int ql, int qr, int val) {
            if (qr <= l || r <= ql) return;
            if (ql <= l && r <= qr) {
                cover[node] += val;
                pull(node, l, r);
                return;
            }
            int mid = (l + r) / 2;
            update(node*2, l, mid, ql, qr, val);
            update(node*2+1, mid, r, ql, qr, val);
            pull(node, l, r);
        }
    };

    double separateSquares(vector<vector<int>>& squares) {
        vector<Event> events;
        vector<long long> xs;

        for (auto& s : squares) {
            long long x1 = s[0];
            long long x2 = s[0] + s[2];
            double y1 = s[1];
            double y2 = s[1] + s[2];

            events.push_back({y1, +1, x1, x2});
            events.push_back({y2, -1, x1, x2});
            xs.push_back(x1);
            xs.push_back(x2);
        }

        sort(xs.begin(), xs.end());
        xs.erase(unique(xs.begin(), xs.end()), xs.end());

        sort(events.begin(), events.end(),
             [](auto& a, auto& b) { return a.y < b.y; });

        SegTree st(xs.size(), xs);

        double totalArea = 0;
        for (int i = 0; i + 1 < events.size(); i++) {
            int x1 = lower_bound(xs.begin(), xs.end(), events[i].x1) - xs.begin();
            int x2 = lower_bound(xs.begin(), xs.end(), events[i].x2) - xs.begin();
            st.update(1, 0, xs.size()-1, x1, x2, events[i].type);

            double dy = events[i+1].y - events[i].y;
            totalArea += dy * st.len[1];
        }

        double half = totalArea / 2.0;
        st = SegTree(xs.size(), xs);  // reset tree
        double curArea = 0;

        for (int i = 0; i + 1 < events.size(); i++) {
            int x1 = lower_bound(xs.begin(), xs.end(), events[i].x1) - xs.begin();
            int x2 = lower_bound(xs.begin(), xs.end(), events[i].x2) - xs.begin();
            st.update(1, 0, xs.size()-1, x1, x2, events[i].type);

            double dy = events[i+1].y - events[i].y;
            double stripArea = dy * st.len[1];

            if (curArea + stripArea >= half) {
                return events[i].y + (half - curArea) / st.len[1];
            }
            curArea += stripArea;
        }
        return events.back().y;
    }
};
